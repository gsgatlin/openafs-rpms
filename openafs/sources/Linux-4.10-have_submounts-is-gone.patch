diff -up openafs-1.6.20.1/src/afs/LINUX/osi_vnodeops.c.Linux-4.10-have_submounts-is-gone openafs-1.6.20.1/src/afs/LINUX/osi_vnodeops.c
--- openafs-1.6.20.1/src/afs/LINUX/osi_vnodeops.c.Linux-4.10-have_submounts-is-gone	2017-03-20 14:43:43.070470030 -0400
+++ openafs-1.6.20.1/src/afs/LINUX/osi_vnodeops.c	2017-03-20 14:52:00.756831584 -0400
@@ -1318,6 +1318,24 @@ afs_linux_dentry_revalidate(struct dentr
 
   good_dentry:
     valid = 1;
+    goto done;
+
+  bad_dentry:
+    valid = 0;
+#ifndef D_INVALIDATE_IS_VOID
+    /* When (v3.18) d_invalidate was converted to void, it also started
+     * being called automatically from revalidate, and automatically
+     * handled:
+     *  - shrink_dcache_parent
+     *  - automatic detach of submounts
+     *  - d_drop
+     * Therefore, after that point, OpenAFS revalidate logic no longer needs
+     * to do any of those things itself for invalid dentry structs.  We only need
+     * to tell VFS it's invalid (by returning 0), and VFS will handle the rest.
+     */
+    if (have_submounts(dp))
+       valid = 1;
+#endif
 
   done:
     /* Clean up */
@@ -1328,6 +1346,7 @@ afs_linux_dentry_revalidate(struct dentr
     if (credp)
 	crfree(credp);
 
+#ifndef D_INVALIDATE_IS_VOID
     if (!valid) {
 	/*
 	 * If we had a negative lookup for the name we want to forcibly
@@ -1340,15 +1359,9 @@ afs_linux_dentry_revalidate(struct dentr
 	} else
 	    d_invalidate(dp);
     }
-
+#endif
     return valid;
 
-  bad_dentry:
-    if (have_submounts(dp))
-	valid = 1;
-    else
-	valid = 0;
-    goto done;
 }
 
 static void
